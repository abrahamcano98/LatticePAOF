/*This file contains the implementation of the  Brakerski/Fan-Vercauteren scheme encryption scheme presented in 
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.400.6346&rep=rep1&type=pdf*/
#![allow(non_snake_case)]

use crate::linearalgebra::{Vec1d,Modq as ModqLa};
use crate::polynomial::{Polynomial,PolynomialVec,normal_pol,gauss_pol,BitDecomp,Modq as ModqPol};
use std::ops::{Add,Mul};

///FV is the struct that represents the parameters employed to encrypt a message over Zq[x]/<x^n+1>


pub struct FV{
    ///n: Length of the field
    ///q: Q that generates the field
    ///mu: Mean of the error distribution
    ///sigma: Standard deviation of the error distribution
    ///t:Max value to be sampled according the sigma: (-t*sigma..t*sigma)
    /// basis: Field of the messages Rt
    ///precision:
    pub n:i64,
    pub q:i64,
    pub mu:f64,
    pub sigma:f64,
    pub t:i64,
    pub precision:usize,
    pub basis: i64,
}
/// Key structure to store the keys employed by the cipher
#[derive(Debug,Clone)]
pub struct Key{
    /// sk:secret key.
    /// pk: public key.
    /// rlk: relinearization key.
    pub sk:Polynomial,
    pub pk:(Polynomial,Polynomial),
    pub rlk:(PolynomialVec,PolynomialVec),
}
/// Polynomial structure to store the components employed by the cipher.
pub struct Ciphertext{
    pub c0:Polynomial,
    pub c1:Polynomial,
}

pub struct MulCiphertext{
    pub c0: Polynomial,
    pub c1: Polynomial,
    pub c2: Polynomial,
}
/// Definition of the trait KeyGen. It generates both sk and pk of the protocol
pub trait KeyGen<T> {
    fn keygen(&self)-> T;
}
/// Implementation of trait KeyGen for RLWE. It samples A from Zq[x]/<x^n+1> and sk,e from the error distribution.
/// The sk is set to be the sk, the pk is equal to (-(a*sk+e),a) and the relinearization key is the tuple
/// (-(ai*sk+ei),ai) for i in 0..l=[log2(q)]

impl KeyGen<Key> for FV{
    fn keygen(&self)->Key{
        let a=normal_pol(self.n,self.q);
        let sk=gauss_pol(self.n, self.q,self.mu,self.sigma,self.t, self.precision);
        let sk2=&sk*&sk;
        let e=gauss_pol(self.n, self.q,self.mu,self.sigma,self.t, self.precision);

        let l=(self.q as f32).log2().ceil() as usize;

        let rlk1=(0..l).map(|_| normal_pol(self.n,self.q)).collect::<Vec<Polynomial>>();

        let eil=(0..l).map(|_| gauss_pol(self.n, self.q,self.mu,self.sigma,self.t, self.precision)).collect::<Vec<Polynomial>>();
       

        let T_vec=T_vector(self.basis,l);
        let rlk0=(0..l).map(|i| &(-1*&(&(&rlk1[i]*&sk)+&eil[i]))+&(T_vec.0[i]*&sk2)).collect::<Vec<Polynomial>>();
        let rlk=(PolynomialVec::new(self.n,self.q,rlk0),PolynomialVec::new(self.n,self.q,rlk1));

        Key{sk:sk.clone(),pk:(-1*&(&(&a*&sk)+&e),a.clone()),rlk:rlk}
    }
}
/// Definition of the trait Encryption. It generates a ciphertext given a plaintext message m and a pk.
pub trait Encryption<T,U> {
    fn encryption(&self,pk:&(Polynomial,Polynomial),m:&T)-> U;
}
/// Implementation of Encryption for RLWE.
///c0=pk[0]*r+e1+delta*m
///c1=pk[1]*r+e2
///
/// Arguments:
///
///* `pk`: A tuple with the components of the pk.
/// * `m`: The plaintext message.
///
///
/// Return:
///
///  Ciphertext structure.
impl Encryption<Polynomial,Ciphertext> for FV{
    fn encryption(&self,pk:&(Polynomial,Polynomial),m:&Polynomial)->Ciphertext{
        let p0=&pk.0;
        let p1=&pk.1;
        let r=&gauss_pol(self.n, self.q,self.mu,self.sigma,self.t, self.precision);
        let e1=&gauss_pol(self.n, self.q,self.mu,self.sigma,self.t, self.precision);
        let e2=&gauss_pol(self.n, self.q,self.mu,self.sigma,self.t, self.precision);

        let delta=(self.q as f64/self.basis as f64).ceil() as i64;
 
        let c0=&(&(p0*r)+e1)+&(delta*m);

        let c1=&(p1*r)+&e2; 
   
       
        Ciphertext{c0:c0,c1:c1}
    }
}
/// Definition of the trait Decryption. It generates a plaintext given a ciphertext and a secret key.
pub trait Decryption<T,U> {
    fn decryption(&self,sk:&Polynomial,c:&T)-> U;
}
/// Implementation of Decryption for FV.
///
/// mdec=[[t/q*(c0+c1*s)]] mod t
///
/// Arguments:
///
///* `sk`: Polynomial with the sk generated by keygen.
/// * `c`: Ciphertext structure
///
///
/// Return:
///
///  Plaintext message.


impl Decryption<Ciphertext,Polynomial> for FV{
    fn decryption(&self,sk:&Polynomial,c:&Ciphertext)->Polynomial{
        let c0=&(c.c0.clone().mod_q());
        let c1=&(c.c1.clone().mod_q());
        let basis=self.basis as f64;
        let m=c0+&(c1*sk);
        let qhr=(self.q as f64/basis).ceil();
        let m_cen=(0..self.n).map(|i| {
            if m.coeffs.0[i as usize]<qhr as i64{
                m.coeffs.0[i as usize]
        }else{
            m.coeffs.0[i as usize]-self.q
        }}).collect::<Vec<i64>>();
        let coeffs=(0..self.n as usize)
        .map(|i| (((basis*(m_cen[i] as f64))/(self.q as f64)).round() as i64)
        .mod_q(self.basis))
        .collect::<Vec<i64>>();
        Polynomial::new(self.n,self.q,Vec1d(coeffs))
    }
}
/// Rust build-in trait to perform the addition of two Ciphertexts
///
///
////// Arguments:
///
/// V:&Ciphertext: Reference to a Ciphertext instance.
///
///
/// Return:
///
/// Given c0=(c00,c01) and c1=(c10,c11), it returns c2=c0+c1=(c00+c10,c01+c11)

impl Add<&Ciphertext> for &Ciphertext
{
    type Output = Ciphertext;

    fn add(self, v: &Ciphertext) -> Ciphertext  {
        Ciphertext{
            c0:(&self.c0+&v.c0),
            c1:(&self.c1+&v.c1),
        }
    }
}
/// Rust build-in trait to perform the multiplication of two Ciphertexts
///
///
////// Arguments:
///
/// V:&Ciphertext: Reference to a Ciphertext instance.
///
///
/// Return:
///
/// Given c0=(c00,c01) and c1=(c10,c11), it returns c2=c0*c1=(c0,c1,c2)=([t/q*(c00*c10)]mod q,[t/q*(c00*c11+c01*c10)]mod q,[t/q*(c01*c11)] mod q)

impl Mul<&Ciphertext> for &Ciphertext
{
    type Output = MulCiphertext;

    fn mul(self, v: &Ciphertext) -> MulCiphertext  {
        let c00=&self.c0;
        let c01=&self.c1; 
        let c10=&v.c0;
        let c11=&v.c1;

        let basis=2;

        



        let c0_coeffs=(c00*c10).coeffs.0.into_iter().
        map(|e| ((((basis as f64)*(e as f64))/(c00.q as f64)).round() as i64)
        .mod_q(c00.q)).
        collect::<Vec<i64>>();

        let c1_coeffs=(&(c00*c11)+&(c01*c10)).coeffs.0.into_iter().
        map(|e| ((((basis as f64)*(e as f64))/(c00.q as f64)).round() as i64)
        .mod_q(c00.q)).
        collect::<Vec<i64>>();


        let c2_coeffs=(c01*c11).coeffs.0.into_iter().
        map(|e| ((((basis as f64)*(e as f64))/(c00.q as f64)).round() as i64)
        .mod_q(c00.q)).
        collect::<Vec<i64>>();



        MulCiphertext{
            c0:Polynomial::new(c00.n,c00.q,Vec1d(c0_coeffs)),
            c1:Polynomial::new(c00.n,c00.q,Vec1d(c1_coeffs)),
            c2:Polynomial::new(c00.n,c00.q,Vec1d(c2_coeffs)),
        }
    }
}
/// Definition of trait relinearization. Given the result of a multiplication of ciphertexts (c0,c1,c2), it computes 
/// c0p=c0+sum_{0}^{l} rlk[i][0]*c2[i] and c1p=c1+sum_{0}^{l} rlk[i][1]*c2[i] 
///
///
pub trait Relin{
    fn relin(&self,rlk:&(PolynomialVec,PolynomialVec))-> Ciphertext;
}
/// Implementation of trait Relin for MulCiphertext. 
///
/// Arguments:
///
/// *`rlk` A tuple with two polynomial vectors.
impl Relin for MulCiphertext{
    fn relin(&self, rlk:&(PolynomialVec,PolynomialVec))->Ciphertext{
        let c0=&self.c0;
        let c1=&self.c1;
        let c2=&self.c2;
        let rlk0=&rlk.0;
        let rlk1=&rlk.1;

        let c2bitdecomp=&(c2.bitdecomp());
      
        let c0p=(c0+&(rlk0*c2bitdecomp)).mod_q();
        let c1p=(c1+&(rlk1*c2bitdecomp)).mod_q();


        Ciphertext{
            c0:c0p,
            c1:c1p,
        }
    }
}
/// Function for sampling of the vector=[T^0,T^1..,T^n]
///
/// Arguments: 
///
/// *`T`: Generator of the input message field
/// *`n`: Length of the vector
///
/// Output: Vec1d 


pub fn T_vector(T:i64,n:usize)->Vec1d{
    Vec1d((0..n).map(|i| T.pow(i as u32)).collect::<Vec<i64>>())
}



